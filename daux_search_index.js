load_search_index({"pages":[{"title":"TypesenseBundle","text":"#Typesense Bundle Be aware: Breaking changes can occur at any time in v0.x.x versions Goal: Provide a simple way to interact with the Typesense API with Symfony Alternative to acseo\/typesense-bundle Use in https:\/\/github.com\/biblioverse\/biblioteca Doc: https:\/\/biblioverse.github.io\/TypesenseBundle\/","tags":"","url":"index.html"},{"title":"Setup","text":"To use the Bundle, you can use the following command: composer require \"biblioverse\/typesense-bundle\" Note that as long as the repo is not ready, you will need to include the repository in your composer.json: { \"repositories\": [ { \"type\": \"vcs\", \"url\": \"https:\/\/github.com\/biblioverse\/TypesenseBundle\" } ] } Then you will need to add the bundle to your config\/bundles.php: &lt;?php $bundles = [ \/\/ ... Biblioverse\\TypesenseBundle::class =&gt; ['all' =&gt; true], ]; And finally, you will need to add the configuration to your config\/packages\/biblioverse_typesense.yaml: parameters: env(TYPESENSE_URL): 'http:\/\/typesense:8108' env(TYPESENSE_KEY): 'mykey' biblioverse_typesense: typesense: uri: '%env(TYPESENSE_URL)%' key: '%env(TYPESENSE_KEY)%' when@test: biblioverse_typesense: auto_update: false This is the minimum configuration needed to use the bundle. By setting auto_update to false on test environment, you make sure that typesense will not update your typesense document when you flush an entity.","tags":"","url":"Setup.html"},{"title":"Mapping","text":"To use Entities mapping, you will need to configure the mapping between your entities and the Typesense collections. You can do that in the configuration. See the example below. biblioverse_typesense: typesense: uri: '%env(TYPESENSE_URL)%' key: '%env(TYPESENSE_KEY)%' collections: houses: entity: 'App\\Entity\\House' mapping: fields: - name: name type: string sort: true facet: true - name: owners type: string[] Configuring the mapping involves the following functionalities: Your entity class is indexed on every insertion\/update\/deletion. You can automatically populate your entities into typesense. A service is automatically available to interact with the Typesense API and hydrate the result with your entities. Limitation: Only entities with a Single Identifier are supported. PR are welcome to support composite keys. #Types The type such as string or string[] are the same as the Typesense types. You can see the full list of types in the Typesense documentation. You can also use the following enum: Biblioverse\\TypesenseBundle\\Type\\DataTypeEnum. #Entity attribute If the field name in the entity is not matching the one on the Typesense collection, you can use the entity_attribute configuration to map the entity field to the collection field. class House { \/\/ ... public function getTypesenseAddress(): string { return implode(', ', [$this-&gt;street, $this-&gt;city, $this-&gt;country]); } } Config ... mapping: fields: - name: address type: string entity_attribute: typesenseAddress #Auto embedding fields You can use the Typesense auto embedding fields to generate embeddings. embedding: name: embedding type: float[] index: true embed: from: [\"field_to_embed\"] model_config: model_name: \"...\" api_key: '...' url: \"...\" You can refer to the Typesense documentation for the details of the configuration. Here is an example for a local ollama embedding that would generate embeddings from the \u201csummary\u201d and \u201ctags\u201d fields, with the nomic-embed-text model. Please note: numDim should be specified and corresponding to your model specifications You need to prefix your model name with openai\/ if you are not using Typesense\u2019s own embedding engine. embedding: name: embedding type: float[] index: true mapped: false numDim: 768 embed: from: [&quot;tags&quot;, &quot;summary&quot;] model_config: model_name: &quot;openai\/nomic-embed-text&quot; api_key: '&lt;key&gt;' url: &quot;http:\/\/localhost:11434\/&quot; #Mapped attribute Unless you want to store embeddings in your database, you can specify mapped: false in the configuration, the embeddings will only live in typesense. In this case, we recommend excluding these fields from being retrieved in the query.","tags":"","url":"Mapping.html"},{"title":"Filling collections","text":"You can fill your Typesense collection with your entities by using the populate command bin\/console biblioverse:typesense:populate This will populate your collection with all the entities from your configuration. If you only want to populate the mapping without data, use the --no-data option. The command will wait for the Typesense server and the database to be ready before starting the population. It will try to check the connectivity every second for --nb-retry times.","tags":"","url":"Filling_collections.html"},{"title":"Searching","text":"To use search results, you have two options: Search with Hydrated results (your entities are hydrated from the search results) Search without hydrated results (you get the raw Typesense results) See also classes SearchResults vs SearchResultsHydrated to get more information about the result. #1. Search with Hydrated results Every mapping that you have configured is automatically available as a SearchCollectionInterface service. To use it, you can inject the service in your controller or service. The name is composed of the collection name with the Search suffix. Example: Given you have declared a collection named books, you can inject the service implementing the SearchCollectionInterface with the name searchBooks. use Biblioverse\\TypesenseBundle\\Search\\SearchCollectionInterface; class SearchHelper { public function construct(private SearchCollectionInterface $searchBooks) { } } As an alternative, you can use the service id: biblioverse_typesense.collection.&lt;name&gt; where &lt;name&gt; is the collection name. #Iterate over the hydrated results $searchResults = $search-&gt;search($query); foreach ($searchResults as $result) { echo $result; \/\/ Your entity } You can use searchRaw to skip the hydration and get the raw Typesense result. #2. Search without hydrated results Use the service SearchInterface: use Biblioverse\\TypesenseBundle\\Search\\SearchInterface; class SearchHelper { public function construct(private SearchInterface $search) { } } #Iterate over raw results $searchResults = $search-&gt;search($query); foreach ($searchResults as $result) { echo $result; \/\/ Your document } #Build the search query To build the search query, you can use the Biblioverse\\TypesenseBundle\\Query\\SearchQuery class. There is a constructor with named parameters to help you build the query, it matches the Typesense API. Please always use named parameters. The order will likely change in the future. &lt;?php use Biblioverse\\TypesenseBundle\\Query\\SearchQuery; $query = new SearchQuery(q: 'my search', queryBy: 'name', filterBy: 'owner', sortBy: 'name:desc'); #Pagination Pagination is automatically provided by the Typesense API if you use the page and per_page parameters in the query. &lt;?php use Biblioverse\\TypesenseBundle\\Query\\SearchQuery; $query = new SearchQuery(q: 'my search', queryBy: 'name', perPage: 10); On the result, you can for example use getTotalPages() and getPage().","tags":"","url":"Searching.html"},{"title":"Custom provider","text":"You can also populate additional collection if you inject a service implementing StandaloneMapperInterface. You will need to convert the data on the fly, and also declare the mapping configuration yourself. You will not be able to use the hydrated result out of the box. Example of a custom mapper, it uses AbstractEntityDataGenerator that will fetch the entities from the database, but it\u2019s not mandatory. &lt;?php namespace App\\Mapper; use App\\Entity\\Book; use Biblioverse\\TypesenseBundle\\Mapper\\Entity\\AbstractEntityDataGenerator; use Biblioverse\\TypesenseBundle\\Mapper\\Mapping\\Mapping; use Biblioverse\\TypesenseBundle\\Mapper\\MappingGeneratorInterface; use Biblioverse\\TypesenseBundle\\Mapper\\StandaloneCollectionManagerInterface; use Biblioverse\\TypesenseBundle\\Type\\DataTypeEnum; use Doctrine\\ORM\\EntityManagerInterface; \/** * @extends AbstractEntityDataGenerator&lt;Book&gt; *\/ class BookDataGenerator extends AbstractEntityDataGenerator { public function __construct( EntityManagerInterface $entityManager, ) { parent::__construct($entityManager, Book::class); } public static function getName(): string { return 'book'; } public function getMapping(): Mapping { $mapping = new Mapping(collectionOptions: new CollectionOptions( tokenSeparators: [' ', '-', \"'\"], symbolsToIndex: ['+', '#', '@', '_'], defaultSortingField: 'sortable_id' )); return $mapping-&gt; add( name: 'id', type: DataTypeEnum::STRING ) -&gt;add( name: 'title', type: DataTypeEnum::STRING ) -&gt;add( name: 'sortable_id', type: DataTypeEnum::INT32 ) -&gt;add( name: 'serie', type: DataTypeEnum::STRING, facet: true, optional: true ) -&gt;add( name: 'summary', type: DataTypeEnum::STRING, optional: true ) -&gt;add( name: 'serieIndex', type: DataTypeEnum::STRING, optional: true ) -&gt;add( name: 'extension', type: DataTypeEnum::STRING, facet: true ) -&gt;add( name: 'authors', type: DataTypeEnum::STRING_ARRAY, facet: true ) -&gt;add( name: 'tags', type: DataTypeEnum::STRING_ARRAY, facet: true, optional: true ) ; } public function transform(object $data): array { return [ 'id' =&gt; (string) $data-&gt;getId(), 'title' =&gt; $data-&gt;getTitle(), 'sortable_id' =&gt; $data-&gt;getId(), 'serie' =&gt; (string) $data-&gt;getSerie(), 'summary' =&gt; (string) $data-&gt;getSummary(), 'serieIndex' =&gt; (string) $data-&gt;getSerieIndex(), 'extension' =&gt; $data-&gt;getExtension(), 'authors' =&gt; $data-&gt;getAuthors(), 'tags' =&gt; $data-&gt;getTags(), ]; } public function support(object $entity): bool { return $entity::class === Book::class; } } #Advanced setFieldConverter usage You can convert the entity\u2019s attribute using a service. use Biblioverse\\TypesenseBundle\\Mapper\\Fields\\FieldMapping; use Biblioverse\\TypesenseBundle\\Mapper\\Mapping; use Biblioverse\\TypesenseBundle\\Mapper\\Converter\\Field\\FieldConverterInterface; \/\/ .. public function getMapping(): Mapping{ $mapping = new Mapping(); $field = new FieldMapping('phone', 'string'); $field-&gt;setFieldConverter(new class(\\libphonenumber\\PhoneNumberUtil::getInstance()) implements FieldConverterInterface{ public function __construct(private \\libphonenumber\\PhoneNumberUtil $libPhoneNumber) {} public function convert(object $entity, mixed $value, FieldMappingInterface $fieldMapping): mixed; { return $this-&gt;libPhoneNumber-&gt;format($value, \\libphonenumber\\PhoneNumberFormat::E164); }); }); return $mapping; } \/\/ ..","tags":"","url":"Custom_provider.html"}]});